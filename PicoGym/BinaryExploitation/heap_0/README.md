# Writeup : heap 0

## Description

Are overflows just a stack concern? 
This challenge explores a heap overflow vulnerability.

- **Binary**: [Download the binary](http://example.com/binary)
- **Source Code**: [Download the source](http://example.com/source)
- **Challenge Instance**: Connect via `nc tethys.picoctf.net 55804`

## Approach

The challenge involves a simple heap overflow vulnerability that allows us to overwrite the value of `safe_var` and subsequently trigger the win condition to retrieve the flag.

## Analysis

### Code Examination

Upon examining the provided source code, we identified the following key points:

- `input_data` and `safe_var` are allocated on the heap with sizes of 5 bytes each.
- The `write_buffer` function uses `scanf` without bounds checking, allowing us to overflow `input_data` and overwrite `safe_var`.

### Initial State

Running the program locally displays the initial heap state:
Heap State:

Address   ->   Heap Data  
 
[*] 0x56348abbf6b0 -> pico

[*] 0x56348abbf6d0 -> bico

### Address Analysis

The address difference between `input_data` and `safe_var` is 0x20 (32 bytes). This means we need to input 32 bytes to fill `input_data` and additional bytes to overwrite `safe_var`.

## Solution

### Exploit Payload

We need to craft a payload that fills `input_data` and changes `safe_var` to trigger the win condition:

```python
payload = 'A' * 32 + 'B'
print(payload)  # Output: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB

